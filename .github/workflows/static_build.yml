name: Termux/Magisk Optimized Build

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Linker version tag (e.g., v1.9.6)'
        required: true
        default: 'v1.9.6'

jobs:
  termux_build:
    runs-on: ubuntu-latest 
    steps:
      - uses: actions/checkout@v4 # 修复弃用问题

      # 1. 设置 .NET 8 SDK
      - name: Setup .NET 8 SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      # 2. 设置 Docker QEMU (用于后续的 Musl 镜像操作)
      - name: Set up QEMU and Docker Buildx
        uses: docker/setup-qemu-action@v3

      # 3. 核心程序构建 (使用 Musl ARM64 目标)
      - name: Publish Musl ARM64 executable
        run: |
          # 确保构建目录存在
          mkdir -p ./public/publish/linux-musl-arm64/linker
          
          # dotnet publish 命令，针对 linux-musl-arm64
          dotnet publish src/linker -c Release -f net8.0 -o ./public/publish/linux-musl-arm64/linker \
            -r linux-musl-arm64 \
            -p:PublishSingleFile=true \
            --self-contained true \
            -p:TrimMode=partial \
            -p:InvariantGlobalization=true \
            -p:StackTraceSupport=false \
            -p:DebuggerSupport=false \
            -p:MetricsSupport=false

      # 4. 准备 Magisk/Termux 依赖包并提取库 (关键修复！)
      - name: Prepare Magisk Dependencies (Extracting Libraries)
        run: |
          MAGISK_PKG_DIR="./public/magisk-pkg"
          PUBLISH_DIR="./public/publish/linux-musl-arm64/linker"
          
          # **关键修改：使用标准的 Alpine 镜像来提取库**
          # **使用 alpine:3.18-arm64v8 作为源，并安装所需的库**
          MUSL_BASE_IMAGE="alpine/git:2.45.0-r0" # 这是一个包含常用工具的 Alpine 镜像，确保有 apk
          
          # 创建 Magisk 包结构
          mkdir -p $MAGISK_PKG_DIR/bin
          mkdir -p $MAGISK_PKG_DIR/lib
          
          # 复制核心程序
          cp $PUBLISH_DIR/linker $MAGISK_PKG_DIR/bin/
          
          # --- 提取 Musl 依赖库 ---
          echo "Starting Docker extraction of Musl dependencies..."
          
          # 1. 创建容器并安装缺失的依赖
          # 我们需要 zlib-dev (提供 libz.so.1) 和 g++ (提供 libstdc++.so.6 和 libgcc_s.so.1)
          CONTAINER_ID=$(docker create $MUSL_BASE_IMAGE)
          
          # 启动容器并在内部安装依赖
          docker start $CONTAINER_ID
          docker exec $CONTAINER_ID apk add --no-cache zlib-dev libstdc++
          
          # 2. Musl C 库 (作为动态链接器) -> 命名为 ld-musl-aarch64.so.1
          docker cp $CONTAINER_ID:/lib/libc.musl-aarch64.so.1 $MAGISK_PKG_DIR/lib/ld-musl-aarch64.so.1
          
          # 3. Zlib (libz.so.1)
          # 在 Alpine 中，libz.so.1 通常在 /lib 或 /usr/lib
          docker cp $CONTAINER_ID:/usr/lib/libz.so.1 $MAGISK_PKG_DIR/lib/
          
          # 4. C++ Runtime (libstdc++.so.6) 和 GCC Runtime (libgcc_s.so.1)
          # 这些库在安装 libstdc++ 包后位于 /usr/lib
          docker cp $CONTAINER_ID:/usr/lib/libstdc++.so.6 $MAGISK_PKG_DIR/lib/
          docker cp $CONTAINER_ID:/usr/lib/libgcc_s.so.1 $MAGISK_PKG_DIR/lib/
          
          # 清理临时容器
          docker stop $CONTAINER_ID
          docker rm $CONTAINER_ID
          
          # --- 打包最终文件 ---
          echo "Packaging final artifact..."
          tar -czvf ./public/linker-magisk-${{ github.event.inputs.version }}.tar.gz -C $MAGISK_PKG_DIR .

      # 5. 上传产物
      - name: Upload Termux/Magisk Package
        uses: actions/upload-artifact@v4 # 修复弃用问题
        with:
          name: linker-magisk-package-${{ github.event.inputs.version }}
          path: ./public/linker-magisk-${{ github.event.inputs.version }}.tar.gz
