# 工作流名称：Magisk 模块自动发布 (Linker + Rurima-AIO 整合)
name: Magisk Module Build and Release

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
  
  workflow_dispatch:
    inputs:
      version:
        description: 'Module version (e.g., v1.0.0) - REQUIRED for manual runs.'
        required: true
        default: 'v-manual-build'

jobs:
  build_module:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        shell: bash
        
    steps:
      - name: 1. Checkout Code
        uses: actions/checkout@v4

      - name: 2. Setup .NET 8 SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      
      - name: 3. Compile Linker (Self-Contained Single File for ARM64)
        run: |
          # 编译 Linker，生成 linux-arm64 平台下自包含的单文件
          dotnet publish src/linker \
            -c Release \
            -f net8.0 \
            -r linux-arm64 \
            --self-contained true \
            -p:PublishSingleFile=true \
            -o ./linker_output
            
      - name: 4. Download Module Template and Rurima-AIO Files
        id: download_deps
        run: |
          # 1. 下载 Magisk Installer 模板 (用于 META-INF)
          TEMPLATE_URL="https://github.com/topjohnwu/Magisk-Module-Installer/archive/master.zip"
          wget -O module-template.zip "$TEMPLATE_URL"
          
          # 2. 下载 Rurima-AIO 文件 (包含 rurima 二进制文件)
          RURIMA_URL=$(curl -sfL https://api.github.com/repos/RuriOSS/rurima-aio/releases/latest | \
            jq -r '.assets[] | select(.name | endswith(".tar")) | .browser_download_url' | head -n 1)
          
          if [ -z "$RURIMA_URL" ]; then
            echo "::error title=Rurima-AIO Asset Not Found::Could not find a .tar asset in the latest RuriOSS/rurima-aio release."
            exit 1
          fi
          wget -O rurima-aio.tar "$RURIMA_URL"

      - name: 5. Create Integrated Module Structure and Files
        run: |
          MODULE_DIR="linker_mod"
          mkdir $MODULE_DIR
          
          # A. 提取 Magisk Installer Template (META-INF)
          mkdir temp_extract
          unzip module-template.zip -d temp_extract
          TEMPLATE_ROOT=$(ls temp_extract | head -n 1)
          mv temp_extract/$TEMPLATE_ROOT/* $MODULE_DIR/
          rm -rf temp_extract module-template.zip
          
          # B. 创建必要的 /system/bin 目录
          MODULE_BIN_DIR="$MODULE_DIR/system/bin"
          mkdir -p "$MODULE_BIN_DIR"
          
          # C. 提取 Rurima-AIO 二进制文件 (只提取 rurima)
          # 解压到临时目录，并查找 rurima 二进制文件
          mkdir rurima_temp
          tar -xf rurima-aio.tar -C rurima_temp
          
          RURIMA_BIN_PATH=$(find rurima_temp -name 'rurima' | head -n 1)
          
          if [ -z "$RURIMA_BIN_PATH" ]; then
             echo "::error title=Rurima Binary Not Found::Could not locate 'rurima' binary in the extracted Rurima-AIO tarball."
             exit 1
          fi
          
          # 移动 rurima 二进制文件到模块 bin 目录
          cp "$RURIMA_BIN_PATH" "$MODULE_BIN_DIR/rurima"
          chmod 755 "$MODULE_BIN_DIR/rurima"
          rm -rf rurima_temp rurima-aio.tar
          
          # D. 获取版本号并生成 module.prop
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=$(echo ${{ github.ref }} | sed 's/refs\/tags\///g')
          fi

          PROP_FILE="$MODULE_DIR/module.prop"
          printf 'id=linker_rurima_integrated\n' > "$PROP_FILE" # 新ID以示区分
          printf 'name=Linker Runner (Integrated Rurima)\n' >> "$PROP_FILE"
          printf "version=%s\n" "$VERSION" >> "$PROP_FILE"
          printf "versionCode=%s\n" "$(date +%s)" >> "$PROP_FILE"
          printf 'author=GithubAction\n' >> "$PROP_FILE"
          printf 'description=Integrates the RuriOSS/rurima-aio environment and Linker for seamless execution.\n' >> "$PROP_FILE"
          
          # E. 复制编译好的 Linker
          LINKER_BIN_NAME="linker"
          cp linker_output/$LINKER_BIN_NAME "$MODULE_BIN_DIR/$LINKER_BIN_NAME"
          
          # F. 生成 linker-wrapper 脚本
          WRAPPER_FILE="$MODULE_BIN_DIR/linker-wrapper"
          printf '#!/system/bin/sh\n' > "$WRAPPER_FILE"
          printf 'RURIMA_BIN="/system/bin/rurima"\n' >> "$WRAPPER_FILE"
          printf 'LINKER_BIN="/system/bin/linker"\n' >> "$WRAPPER_FILE"
          printf '\n' >> "$WRAPPER_FILE"
          printf 'if [ -x "$RURIMA_BIN" ]; then\n' >> "$WRAPPER_FILE"
          printf '    # Rurima 整合在此模块中，确保使用 rurima 启动\n' >> "$WRAPPER_FILE"
          printf '    exec "$RURIMA_BIN" "$LINKER_BIN" "$@"\n' >> "$WRAPPER_FILE"
          printf 'else\n' >> "$WRAPPER_FILE"
          printf '    # 警告：此分支不应被触发，但作为安全回退保留\n' >> "$WRAPPER_FILE"
          printf '    exec "$LINKER_BIN" "$@"\n' >> "$WRAPPER_FILE"
          printf 'fi\n' >> "$WRAPPER_FILE"
          
          # G. 设置权限
          chmod 755 "$WRAPPER_FILE"
          chmod 755 "$MODULE_BIN_DIR/$LINKER_BIN_NAME"

      - name: 6. Finalize and Zip Module
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=$(echo ${{ github.ref }} | sed 's/refs\/tags\///g')
          fi
          
          echo "Building module version: $VERSION"
          
          cd linker_mod
          zip -qr ../linker_magisk_mod-${VERSION}.zip .
          cd ..
          
      - name: 7. Create GitHub Release and Upload Asset
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event_name == 'workflow_dispatch' && format('manual-{0}', github.event.inputs.version) || github.ref }}
          files: linker_magisk_mod-*.zip
          prerelease: false
          body: |
            ## Linker Magisk 模块 ${{ github.event_name == 'workflow_dispatch' && format('Manual Build v{0}', github.event.inputs.version) || format('Release v{0}', github.ref_name) }}
            
            此模块是一个 **自包含（Self-Contained）** 的 Magisk 模块。
            
            - **核心程序:** Linker (自包含 .NET 8.0/linux-arm64)
            - **环境整合:** **已完全整合** RuriOSS/rurima-aio 核心二进制文件。
            - **依赖:** 无外部 Magisk 模块依赖。
            
            **用法:** 安装后重启，在任何 Shell (ADB 或 Termux su) 中运行 `linker-wrapper`。
