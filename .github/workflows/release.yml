# 工作流名称：Magisk 模块自动发布 (Linker + Magisk 模板集成)
name: Magisk Module Build and Release

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
  
  workflow_dispatch:
    inputs:
      version:
        description: 'Module version (e.g., v1.0.0) - REQUIRED for manual runs.'
        required: true
        default: 'v-manual-build'

jobs:
  build_module:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        shell: bash
        
    steps:
      - name: 1. Checkout Code
        uses: actions/checkout@v4

      - name: 2. Setup .NET 8 SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      
      - name: 3. Compile Linker (Self-Contained Single File for ARM64)
        run: |
          dotnet publish src/linker \
            -c Release \
            -f net8.0 \
            -r linux-arm64 \
            --self-contained true \
            -p:PublishSingleFile=true \
            -o ./linker_output
            
      - name: 4. Download Magisk Module Template
        run: |
          # 使用 topjohnwu 的 Magisk Module Installer 作为基础 (包含 META-INF)
          # 注意：这个仓库不包含 module.prop，我们需要自己创建
          TEMPLATE_URL="https://github.com/topjohnwu/Magisk-Module-Installer/archive/master.zip"
          wget -O module-template.zip "$TEMPLATE_URL"
          
      - name: 5. Prepare Module Structure (Robust Extraction)
        run: |
          # 1. 解压到临时目录
          mkdir temp_extract
          unzip module-template.zip -d temp_extract
          
          # 2. 动态找到解压后的根目录 (通常是 Magisk-Module-Installer-master)
          TEMPLATE_ROOT=$(ls temp_extract | head -n 1)
          echo "Found template root: $TEMPLATE_ROOT"
          
          # 3. 移动内容到 linker_mod
          mkdir linker_mod
          mv temp_extract/$TEMPLATE_ROOT/* linker_mod/
          
          # 4. 清理
          rm -rf temp_extract module-template.zip

      - name: 6. Generate Module Config and Scripts
        run: |
          # 获取版本号
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=$(echo ${{ github.ref }} | sed 's/refs\/tags\///g')
          fi
          
          # A. 手动生成 module.prop (不再依赖 sed 修改不存在的文件)
          # 使用 printf 避免 YAML 多行字符串的缩进错误
          PROP_FILE="linker_mod/module.prop"
          printf 'id=linker_rurima\n' > "$PROP_FILE"
          printf 'name=Linker Runner Module\n' >> "$PROP_FILE"
          printf "version=%s\n" "$VERSION" >> "$PROP_FILE"
          printf "versionCode=%s\n" "$(date +%s)" >> "$PROP_FILE"
          printf 'author=GithubAction\n' >> "$PROP_FILE"
          printf 'description=Runs the Linker binary via the Rurima-AIO environment.\n' >> "$PROP_FILE"
          
          # B. 确保 customize.sh 存在 (如果模板没有)
          touch linker_mod/customize.sh
          
          # C. 准备系统二进制目录
          MODULE_BIN_DIR="linker_mod/system/bin"
          mkdir -p "$MODULE_BIN_DIR"
          
          # D. 复制编译好的 Linker
          cp linker_output/linker "$MODULE_BIN_DIR/"
          
          # E. 生成 linker-wrapper 脚本
          WRAPPER_FILE="$MODULE_BIN_DIR/linker-wrapper"
          printf '#!/system/bin/sh\n' > "$WRAPPER_FILE"
          printf 'RURIMA_BIN="/system/bin/rurima"\n' >> "$WRAPPER_FILE"
          printf 'LINKER_BIN="/system/bin/linker"\n' >> "$WRAPPER_FILE"
          printf '\n' >> "$WRAPPER_FILE"
          printf 'if [ -x "$RURIMA_BIN" ]; then\n' >> "$WRAPPER_FILE"
          printf '    exec "$RURIMA_BIN" "$LINKER_BIN" "$@"\n' >> "$WRAPPER_FILE"
          printf 'else\n' >> "$WRAPPER_FILE"
          printf '    echo "Rurima not found, falling back..."\n' >> "$WRAPPER_FILE"
          printf '    exec "$LINKER_BIN" "$@"\n' >> "$WRAPPER_FILE"
          printf 'fi\n' >> "$WRAPPER_FILE"
          
          # F. 设置权限
          chmod 755 "$WRAPPER_FILE"
          chmod 755 "$MODULE_BIN_DIR/linker"

      - name: 7. Finalize and Zip Module
        run: |
          # 获取版本号用于文件名
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=$(echo ${{ github.ref }} | sed 's/refs\/tags\///g')
          fi
          
          cd linker_mod
          zip -qr ../linker_magisk_mod-${VERSION}.zip .
          cd ..
          
      - name: 8. Create GitHub Release and Upload Asset
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event_name == 'workflow_dispatch' && format('manual-{0}', github.event.inputs.version) || github.ref }}
          files: linker_magisk_mod-*.zip
          prerelease: false
          body: |
            ## Linker Magisk 模块 ${{ github.event_name == 'workflow_dispatch' && format('Manual Build v{0}', github.event.inputs.version) || format('Release v{0}', github.ref_name) }}
            
            - **核心程序:** Linker (自包含 .NET 8.0/linux-arm64)
            - **基础模板:** TopJohnWu Magisk Module Installer
            - **依赖:** RuriOSS/rurima-aio (需单独安装)
            
            **用法:** 重启后，在任何 Shell (ADB 或 Termux su) 中运行 `linker-wrapper`。
